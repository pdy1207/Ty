변수명 : 타입명

- 장점 ) 타입이 실수로 변경될 때 에러내줌
- 변수에 **실드** 씌우는 것!
- undefind / null 타입도 있음!

## ProTip!

### 타입지정 원래 자동으로 됩니다!

※ 온갖 곳에 다 타입지정 안해도됨!! 변수 생성시 타입스크립트가 타입을 자동으로 부여해줌!

## 애매모호한 타입은?

```
let 축구: Number | String = 123;

let 배열: (Number | String)[] = [1, "2", 3];

let 오브젝트: { a: string | Number } = { a: "123" };
```

## any 타입 | unknown 타입

### any

- => 타입 실드 해제 문법
- 그냥 아무거나 막 넣어도 오류 없음!

### unknown

- 모든 자료형 허용!
- any 보다 안전함 이유는?
- 간단한 수학연산도 타입이 맞아야함.
- unknown은 number타입이 아님

※ 타입 엄격하게 지켜야함

```
let 이름 : unknown;
이름 = 123;
이름 = {};

let 변수1 :string = 이름;  // 이러면 Error!
```

## 함수에 타입 지정 / void 타입

```
function 함수입니다(x: number): number {
  return x * 2;
} // return 되는 값은 숫자타입으로 제한함


함수입니다(10);

void 타입 활용가능

function 함수입니다(x?: number): void {

}

- 실수로 뭔가 return 하는걸 사전에 막을 수 있음
- 타입지정된 파라미터는 필수로 지정해야함
- 파라미터변수'?' :타입 ex_ age? :number
- *중요* 변수? :number === 변수 :number | undefinde와 같음
```

- 자 그러면? 해당 코드가 에러가 나는 이유는?

```
function 함수입니다2(x :number | string) : void {
    console.log(x + 3)
}
함수입니다2(2);
```

※ answer : 타입이 숫자인지 문자인지 애매하잖음 타입스크립트는 **엄근진** 을 좋아하므로 에러가남

## 그래서 Type Narrowing 써야하는데..

- typeof 연산자

- 변수 타입이 아직 불확실하면 if문 등으로 Narrowing 해줘야 조작가능

```
function 내함수(x: number | string) {
 if(typeof x === 'number'){
  return x + 1
 } else{
  return x + "1";
 }
}
내함수(123);

function 내함수(x: number | string) {
  let array: number[] = [];
  if (typeof x === "number") {
    array[0] = x;
  }
}
내함수(123);
```

### 주의사항!!!

- if문 썻으면 끝가지 써야함 즉 else, else if 안쓰면 에러 잡을 수 있음.

- 현재 변수의 타입이 뭔지 특정지을 수 있기만 하면 다 이정해준다.

- Narrowing 판정해주는 문법

```
typeof 변수

속성명 in 오브젝트자료

인스턴스 instanceof 부모
```

## assertion 문법 (타입 덮어쓰기) Narrowing 귀찮을때

- 근데 이거에 용도는 ?

1. Narrowing 할때 쓰는게 맞음
2. 무슨 타입이 들어올지 100% 확실할때.

**왜 타입에러가 나는지 모르게쓰무리다할때**

```
function 내함수(x: number | string) {
  let array: number[] = [];
  array[0] = x as number;
}
내함수(123);
```
