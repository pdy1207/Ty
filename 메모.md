### rest parameter 타입지정가능함!

- rest parameter가 머임 ?

```
사실 JS 문법임..

점 3개 붙이면 rest parameter임 파라미터 100만개 들어올 수 있다는 뜻

단, 다른 파라미터 있으면 맨 뒤에만 사용가능

function 함수(...a) {
  console.log(a);
}

함수(1, 5, 3, 6, 7); // 몇개의 파라미터가 들어올지 아직 모를때

let arr = [1, 2, 3];
let arr2 = [4, 5];
let arr3 = [...arr, ...arr2];

// ... 괄호 벗겨주세요 문법임 이러한게 spread operator 문법임

//destructuring 개념

let [변수1,변수2] = ['안녕',100];

console.log(변수1) // '안녕'

//object 자료

let { student, age6 } = { student: true, age6: 20 };

console.log(student);


//object 자료

let person = {student: true , age : 20}

function 함수({student,age} : {student: boolean, age : number}){
    console.log(student,age)
}

함수({student: true , age : 20})

```

## Narrowing 할 수 있는 방법 더 알아보기

- null & nudefined 타입 체크하는 경우 매우 잦다

```
type Fish = { swim: string };
type Bird = { fly: string };

function 함수2(animal: Fish | Bird) {
  if ("swim" in animal) {
    animal.swim;
  }
}
// in키워드로 objectnarrowing 가능 속성명 in 오브젝트자료

- instanceof 연산자로 object narrowing 가능

let 날짜 = new Date()

if(날짜 instanceof Date){

}

// 비슷한 object 타입일 경우, literal type 강제로 만들어두면 나중에 도움됨
// object 타입마다 literal type 만들어두면 narrowing 편리하다!


type Car = {
  wheel: "4개";
  color: string;
};

type Bike = {
  wheel: "2개";
  color: string;
};

function 함수(x: Car | Bike) {
  if (x.wheel == "4개") {
  }
}

```

### 요약

- 논리적으로 이 타입인지 특정 지을 수 있으면 narrowing 인정해준다!

## never type !

function return 값에 붙일 수 있는 never type

- 조건 1. return 값이 없어야함
- 조건 2. endpoint가 없어야함

```
function 함수():never{
    throw new Error()
    while(true){

    }
}

// what is 끝나지 않는 함수 (endpoint가 없는 함수)

그래서 어따씀? 사실 쓸대없음 void 로 쓰면됨

function 함수(parameter: string) {
  if (typeof parameter == "string") {
    console.log(parameter);
  } else {
  }
}

//never 타입 등장하는 경우

// 1. 뭔가 이상한 narrowing

// 2. 어떤 함수 표현식은 return 타입이 자동으로 never

let 하암수 = function () {
  throw new Error();
};

굳이 쓸 일은 없고 등장하면 이해할 수만 있도록!!
```

## 타입스크립트의 강점이 머임

- 객체지향 언어같은 문법도 제공한다

```
class 많이 만들어서 개발하려면

public private protected static 키워드
```

- class에서 쓰는 public 키워드
- public 붙으면 모든 자식들이 이용가능

```
class User123 {
  public name = "kim";
  constructor(a) {
    this.name = a;
  }
}
let 유저1 = new User("park");
유저1.name = "안녕";

사실 있으나 마나.. 숨겨져있음!!
```

- class에서 쓰는 private 키워드
- private 붙으면 class 안에서만 수정, 이용가능

```
class User123 {
  name: string;
  familyName: string = "kim";
  constructor(a) {
    this.name = a;
  }
}
let 유저1 = new User("park");

console.log(유저1); // 'park'



class User123 {
  name: string;
  private familyName: string = "kim";
  constructor(a) {
    this.name = a + this.familyName;
  }
}
let 유저1 = new User("park");

console.log(유저1); // 'park' + 'kim'

// 근데 실수로 familyName 을 다른걸로 변경하면 큰일남..

// 그래서 방지하고 싶어서 나온게 private 키워드


private은 수정불가가 아님
class {} 안에서만 수정, 사용가능



근데 급하게 바꿔야한다면???


class User123 {
  name: string;
  private familyName: string = "kim";
  constructor(a) {
    this.name = a + this.familyName;
  }
  이름변경함수() {
    this.familyName = "park";
  }
}
let 유저1 = new User("park");
유저1.이름변경함수();

데이터 외부로부터 보호하고 싶을때 자주 사용하는 패턴입니당
```

- public 키워드 쓰면 this.어쩌구 생략가능

```
class Persona {
  constructor(public name, age :number .... ) {}
}

let 자식 = new Persona("kim");
console.log(자식); // kim
```

## class 복사하고 싶네...

```
class User123123 {
  x = 10;
}

class NewUser123123 extends User123123 {
  // 여기에 User에 있던거 복붙해준다!
}

let 사람 = new NewUser123123();

console.log(사람); // 10

```

- private,protected 붙이면 class {} 안에서만 사용가능
- 현재 class {} 안에서 + extends 된 class {} 안에서 사용가능
- protected : extends된 class는 사용가능, 자식들 사용불가능
- private : extends 된 class는 사용불가능, 자식들 사용불가능

```
class User123123 {
 protected  x = 10;

}

class NewUser123123 extends User123123 {
    doThis(){
        this.x = 20;
    }
}
```

- 근데, static 키워드 붙이면 부모 class에 직접 부여가 된다! (+ 자식에게 안물려줌!)
- static 키워드 붙이면 부모 class에 직접 부여됨 (+ 자식에게 안물려줌, extends 하면 잘 따라옴)

```
class TestUser {
  static x = 10;
  y = 20;
}

let 자식임 = new TestUser();
console.log(TestUser.x); // 이건 되는데
console.log(자식임.x) //이게 안됨

```

- 예시

```
class TestUser {
    static skill = 'js'
    intro =  this.skill + ' 전문가입니다.';
}

let 철수임 = new TestUser();
console.log(철수임)

이게안됨 static은 부모와 TestUser만 쓸수있음 그러므로

class TestUser {
    static skill = 'js'
    intro =  TestUser.skill + ' 전문가입니다.';
}

let 철수임 = new TestUser();
console.log(철수임)

중간에 바꾸고싶으면?

class TestUser {
    static skill = 'js'
    intro =  TestUser.**skill** + ' 전문가입니다.';
}

let 철수임 = new TestUser();
console.log(철수임)

TestUser.skill = 'ts'

let 철수임2 = new TestUser();
console.log(철수임2) // ts 전문가입니다.


```

## import export 설명

- 그냥 내보내겠다~ 라는 뜻임

```
a.ts

export var 이름이에요 = 'kim';
var 나이에요 = 20;


index.ts

import { 변수명 } from './a';
import { 이름이에요 } from './a';

import { 이름이에요 } from "./a";
console.log(이름이에요 ) // kim
```

- 옛날 문법

```
export type Name = string;
export var 나이 = 20;


import { Name, 나이 } from "./a";

let 변수: Name = "park";
```

- 문제점이 변수명 맨날 겹침..
- 지금은 다른 파일에서 쓸 변수를 export import 로 선택가능!

## 타입 숨기기 문법 namespace

```
namespace 네임스페이스 {
 export type Nameing = string | number;
}

object안에 담긴거임

&& module도 namespace와 같은 소리

쓰는법이 네임스페이스.Nameing

근데 이게 옛날에 숨기는방법임
```

- `///<reference path="./a.ts" />` 옛날에 불러오는 방법임

- 지금은 import export만으로도 이런 문제 그나마 해결가능

- interface 이런 것들도 export 가능

## 함수에 타입도 파라미터로 입력가능

- Generice함수 만들기

```
function 함수<MyType>(x: MyType[]) :MyType {
  return x[0];
}

let a = 함수<number>([4, 2]);
console.log(a);


어딜넣어도 가능하다!
그러므로 a + 1해도 오류안생김
```

- Generice 함수 장점 : 확장성이 조금있어보인다.
- 매번 다른 타입 출력가능하다.
- 타입파라미터 가끔 자동으로 유추하다

### 타입파라미터 제한두기

```
function 함수<MyType extends number>(x: MyType) {
  return x - 1;
}
let a = 함수<number>(100);
```

- 커스텀 타입으로도 타입파라미터 제한가능

```
interface LengthCheck {
  length: number;
}

function 함수<MyType extends LengthCheck>(x: MyType) {
  return x.length;
}
let a = 함수<number>(100);


```

1. 함수에 파라미터 넣을 수 있다.

2. extends 키워드로 넣을 수 있는 타입제한가능

3. class에도 타입파라미터 넣을 수 있음

## React + TypeScript

### 요약

1. 변수 , 함수 만들 때 타입지정하면 끝
2. 이상한 타입도 몇개알아야 끝

```
npx create-react-app 프로젝트명 --template typescript
```

- 기존프로젝트에 추가 (별로 추천안함)
- 새로 만드는게 더 안전하기 때문에...

```
npm install --save typescript @types/node @types/react @types/react-dom @types/jest
```

JSX 문법을 쓰는 파일은 .tsx

일반 파일은 .ts

1. 일반변수,함수 만들때 타입지정 잘하면됨

2. jsx 표현하는 타입있음

3. component 만들 때 타입지정

- 함수타입지정은 파라미터 & return 값

4. component props 타입지정

function Profile(props: { name: string }): JSX.Element { 너무 길면 type alias

5. react에서는 props잘못 전달해서 에러가 잦다.

6. useState 타입지정 <- 자동으로 됭당 (알아서해준당)

7. 근데 string | number 타입을? 굳이...

```
let [user, setUser] = useState<string | number>("park");
```

8. 나머지는 나도 모르겠다 검색하자!

### 갑분싸 React Redux 정리하자면

1. 모든 컴포넌트가 state공유 가능

2. 수정방법을 파일 한곳에 정의해둠
