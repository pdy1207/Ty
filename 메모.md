### rest parameter 타입지정가능함!

- rest parameter가 머임 ?

```
사실 JS 문법임..

점 3개 붙이면 rest parameter임 파라미터 100만개 들어올 수 있다는 뜻

단, 다른 파라미터 있으면 맨 뒤에만 사용가능

function 함수(...a) {
  console.log(a);
}

함수(1, 5, 3, 6, 7); // 몇개의 파라미터가 들어올지 아직 모를때

let arr = [1, 2, 3];
let arr2 = [4, 5];
let arr3 = [...arr, ...arr2];

// ... 괄호 벗겨주세요 문법임 이러한게 spread operator 문법임

//destructuring 개념

let [변수1,변수2] = ['안녕',100];

console.log(변수1) // '안녕'

//object 자료

let { student, age6 } = { student: true, age6: 20 };

console.log(student);


//object 자료

let person = {student: true , age : 20}

function 함수({student,age} : {student: boolean, age : number}){
    console.log(student,age)
}

함수({student: true , age : 20})

```

## Narrowing 할 수 있는 방법 더 알아보기

- null & nudefined 타입 체크하는 경우 매우 잦다

```
type Fish = { swim: string };
type Bird = { fly: string };

function 함수2(animal: Fish | Bird) {
  if ("swim" in animal) {
    animal.swim;
  }
}
// in키워드로 objectnarrowing 가능 속성명 in 오브젝트자료

- instanceof 연산자로 object narrowing 가능

let 날짜 = new Date()

if(날짜 instanceof Date){

}

// 비슷한 object 타입일 경우, literal type 강제로 만들어두면 나중에 도움됨
// object 타입마다 literal type 만들어두면 narrowing 편리하다!


type Car = {
  wheel: "4개";
  color: string;
};

type Bike = {
  wheel: "2개";
  color: string;
};

function 함수(x: Car | Bike) {
  if (x.wheel == "4개") {
  }
}

```

### 요약

- 논리적으로 이 타입인지 특정 지을 수 있으면 narrowing 인정해준다!

## never type !

function return 값에 붙일 수 있는 never type

- 조건 1. return 값이 없어야함
- 조건 2. endpoint가 없어야함

```
function 함수():never{
    throw new Error()
    while(true){

    }
}

// what is 끝나지 않는 함수 (endpoint가 없는 함수)

그래서 어따씀? 사실 쓸대없음 void 로 쓰면됨

function 함수(parameter: string) {
  if (typeof parameter == "string") {
    console.log(parameter);
  } else {
  }
}

//never 타입 등장하는 경우

// 1. 뭔가 이상한 narrowing

// 2. 어떤 함수 표현식은 return 타입이 자동으로 never

let 하암수 = function () {
  throw new Error();
};

굳이 쓸 일은 없고 등장하면 이해할 수만 있도록!!
```

## 타입스크립트의 강점이 머임

- 객체지향 언어같은 문법도 제공한다

```
class 많이 만들어서 개발하려면

public private protected static 키워드
```

- class에서 쓰는 public 키워드
- public 붙으면 모든 자식들이 이용가능

```
class User123 {
  public name = "kim";
  constructor(a) {
    this.name = a;
  }
}
let 유저1 = new User("park");
유저1.name = "안녕";

사실 있으나 마나.. 숨겨져있음!!
```

- class에서 쓰는 private 키워드
- private 붙으면 class 안에서만 수정, 이용가능

```
class User123 {
  name: string;
  familyName: string = "kim";
  constructor(a) {
    this.name = a;
  }
}
let 유저1 = new User("park");

console.log(유저1); // 'park'



class User123 {
  name: string;
  private familyName: string = "kim";
  constructor(a) {
    this.name = a + this.familyName;
  }
}
let 유저1 = new User("park");

console.log(유저1); // 'park' + 'kim'

// 근데 실수로 familyName 을 다른걸로 변경하면 큰일남..

// 그래서 방지하고 싶어서 나온게 private 키워드


private은 수정불가가 아님
class {} 안에서만 수정, 사용가능



근데 급하게 바꿔야한다면???


class User123 {
  name: string;
  private familyName: string = "kim";
  constructor(a) {
    this.name = a + this.familyName;
  }
  이름변경함수() {
    this.familyName = "park";
  }
}
let 유저1 = new User("park");
유저1.이름변경함수();

데이터 외부로부터 보호하고 싶을때 자주 사용하는 패턴입니당
```

- public 키워드 쓰면 this.어쩌구 생략가능

```
class Persona {
  constructor(public name, age :number .... ) {}
}

let 자식 = new Persona("kim");
console.log(자식); // kim
```

## class 복사하고 싶네...

```
class User123123 {
  x = 10;
}

class NewUser123123 extends User123123 {
  // 여기에 User에 있던거 복붙해준다!
}

let 사람 = new NewUser123123();

console.log(사람); // 10

```

- private,protected 붙이면 class {} 안에서만 사용가능
- 현재 class {} 안에서 + extends 된 class {} 안에서 사용가능
- protected : extends된 class는 사용가능, 자식들 사용불가능
- private : extends 된 class는 사용불가능, 자식들 사용불가능

```
class User123123 {
 protected  x = 10;

}

class NewUser123123 extends User123123 {
    doThis(){
        this.x = 20;
    }
}
```

- 근데, static 키워드 붙이면 부모 class에 직접 부여가 된다! (+ 자식에게 안물려줌!)
- static 키워드 붙이면 부모 class에 직접 부여됨 (+ 자식에게 안물려줌, extends 하면 잘 따라옴)

```
class TestUser {
  static x = 10;
  y = 20;
}

let 자식임 = new TestUser();
console.log(TestUser.x); // 이건 되는데
console.log(자식임.x) //이게 안됨

```

- 예시

```
class TestUser {
    static skill = 'js'
    intro =  this.skill + ' 전문가입니다.';
}

let 철수임 = new TestUser();
console.log(철수임)

이게안됨 static은 부모와 TestUser만 쓸수있음 그러므로

class TestUser {
    static skill = 'js'
    intro =  TestUser.skill + ' 전문가입니다.';
}

let 철수임 = new TestUser();
console.log(철수임)

중간에 바꾸고싶으면?

class TestUser {
    static skill = 'js'
    intro =  TestUser.skill + ' 전문가입니다.';
}

let 철수임 = new TestUser();
console.log(철수임)

TestUser.skill = 'ts'

let 철수임2 = new TestUser();
console.log(철수임2) // ts 전문가입니다.


```
