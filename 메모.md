## 객체지향 Class 문법

- 비슷한 object 많이 만들일 있으면 class 만들어 쓰기!

- object 뽑는 기계임

-

```
function 기계(a, b) {
  this.q = a;
  this.w = b;
}

var nunu = new 기계("consume", "snowball");
var garen = new 기계("strike", "courage");
```

### ES6문법으로 Class

```
class Hero {
  constructor(a, b) {
    this.q = a;
    this.w = b;
  }
}
```

## 객체 지향 prototype문법

- 자식 object에게 데이터 물려주기

- prototype 은 유전자!

- nunu가 name을 가지고 있지 않으면 nunu 부모유전자에게 물어봄(거기 name이 있으면 출력)

```
function 기계(a, b) {
  this.q = a;
  this.w = b;
}
기계.prototype.name = "kim";

nunu.name
'kim'

var nunu = new 기계("consume", "snowball");

// Q. array자료에 .sort() 붙일 수 있는 이유는?

var 어레이 = [4, 2, 1];

var 어레이 = new Array(4, 2, 1);
어레이.sort();
// Array.prototype <- 여기에 있기 때문에

Array.prototype.함수 = function(){}
```

---

## TS에서 class

```
class Person123 {
  name: string; 미리 타입을 지정해야함
  constructor() {
    this.name = "kim";
  }
}
let 사람1 = new Person123();


class Person123 {
  name: string;
  constructor(a: string) {
    this.name = a;
  }
}
let 사람1 = new Person123("park");


prototype함수는 !!?


class Person123 {
  name: string;
  constructor(a: string) {
    this.name = a;
  }

  함수(a: number) {
    console.log("넌 몇살이니?" + a);
  }
}
let 사람1 = new Person123("qewr");

```

## type 키워드로 타입변수 생성가능 / interface 키워드도 가능!

```
type Square = {
  color: String;
  width: number;
};

interface Square {
  color: String;
  width: number;
}

let 네모: Square = {
  color: "red",
  width: 100,
};

```

### 장 & 단점

- extends로 복사가능!

```
interface Student {
  name: string;
}

interface Teacher extends Student {
  age: number;
}

let 학생: Student = {
  name: "kim",
};

let 선생: Teacher = {
  name: "kim",
  age: 20,
};

타입도 가능함 !  & 기호 (intersection type)

그러나 이러한것으 두 타입을 전부 만족하는 타입이라는 뜻!

type Animal2 = {name : string}
type Cat  = {age :number} & Animal2
```

### type vs interface

- interface 는 중복선언 가능

- type 은 중복선언 불가능

- 외부라이브러리 같은 경우는 interface많이 씀! 왜? 추후에 타입에 추가하는게 더 쉽다!

- 그러므로 다른사람이 이용많이 할것 같으면 interface 쓰는게 좋다! 특히 object!
